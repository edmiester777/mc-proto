import json
import os
import urllib.request
import subprocess
from os import path

# 1.18.2 server direct download link
SERVER_URL = 'https://launcher.mojang.com/v1/objects/c8f83c5655308435b3dcf03c06d9fe8740a77469/server.jar'

# setup constants
BOOTSTRAP_DIR = path.abspath('./bootstrap')
SERVER_PATH = path.join(BOOTSTRAP_DIR, 'server.jar')
REPORTS_DIR = path.join(BOOTSTRAP_DIR, 'reports')

GEN_HEADER_PATH = path.join('mc-proto', 'minecraft', 'generated.h')
GEN_SOURCE_PATH = path.join('mc-proto', 'minecraft', 'generated.cpp')

FILE_HEADER_COMMENT = \
"""
// generated by bootstrap.py
// do not modify
"""

# setting up all data for bootstrap
if not path.exists(BOOTSTRAP_DIR):
    os.mkdir(BOOTSTRAP_DIR)

if not path.exists(SERVER_PATH):
    print('Downloading server jar...')
    urllib.request.urlretrieve(SERVER_URL, SERVER_PATH)

# generating raw data
if not path.exists(REPORTS_DIR):
    os.mkdir(REPORTS_DIR)

if len(os.listdir(REPORTS_DIR)) == 0:
    print('Generating raw data...')
    subprocess.run(
        f'java "-DbundlerMainClass=net.minecraft.data.Main" -jar {SERVER_PATH} -reports -all --output="{BOOTSTRAP_DIR}"', 
        cwd=BOOTSTRAP_DIR
    )

# generating type code from reports
if path.exists(GEN_HEADER_PATH):
    os.remove(GEN_HEADER_PATH)
if path.exists(GEN_SOURCE_PATH):
    os.remove(GEN_SOURCE_PATH)

header_content = ''
source_content = ''

# parsing blocks
blockjson = json.load(open(path.join(REPORTS_DIR, 'blocks.json')))
blockdefs = {}
for key in blockjson:
    # list of numerical IDs related to this block
    ids = [state['id'] for state in blockjson[key]['states']]
    deflt = [state['id'] for state in blockjson[key]['states'] if 'default' in state and state['default']][0]
    
    # enumify this name
    stripped_name = str(key[len('minecraft:'):])
    enum_name = stripped_name.upper()
    blockdefs[str(key)] = {
        'enum_name': enum_name,
        'ids': ids,
        'default': deflt
    }

# generating data
block_enum_name = 'BlockTypes'
block_keys_strs = ''
block_enum_data = ''
block_str_to_enum_data = ''
block_enum_to_str_data = ''
for key in blockdefs.keys():
    block = blockdefs[key]
    block_keys_strs += f'char* __KEY_{block["enum_name"]} = (char*)"{key}";\n'
    block_str_to_enum_data += f'{{ __KEY_{block["enum_name"]}, ({block_enum_name}){block["default"]} }},\n'
    if len(block['ids']) > 1:
        for i in range(len(block['ids'])):
            block_enum_data += f'{block["enum_name"]}_{i + 1} = {block["ids"][i]}, {" //default" if block["default"] == block["ids"][i] else ""}\n'
            block_enum_to_str_data += f'{{ ({block_enum_name}){block["ids"][i]}, __KEY_{block["enum_name"]} }},\n'
    else:
        block_enum_data += f'{block["enum_name"]} = {block["default"]},\n'
        block_enum_to_str_data += f'{{ ({block_enum_name}){block["default"]}, __KEY_{block["enum_name"]} }},\n'


header_content += \
f"""
enum class {block_enum_name} {{{block_enum_data}}};

{block_enum_name} get_block_type_from_string(const char* s);
const char* get_string_from_block_type({block_enum_name} type);
"""

source_content += \
f"""
{block_keys_strs}

std::map<char*, {block_enum_name}, __cmp_chr_ptr> BLOCK_STRING_TO_DEFAULT_TYPE = {{ {block_str_to_enum_data} }};
std::map<{block_enum_name}, char*> BLOCK_TYPE_TO_STRING_MAP = {{ {block_enum_to_str_data} }};

{block_enum_name} get_block_type_from_string(const char* s)
{{
    return BLOCK_STRING_TO_DEFAULT_TYPE[(char*)s];
}}

const char* get_string_from_block_type({block_enum_name} type)
{{
    return BLOCK_TYPE_TO_STRING_MAP[type];
}}
"""


# write generated data
hfile = open(GEN_HEADER_PATH, 'w')
sfile = open(GEN_SOURCE_PATH, 'w')

hfile.write(f'''
#pragma once

{FILE_HEADER_COMMENT}

#include <string>
#include <map>

namespace minecraft
{{
{header_content}
}}
''')

sfile.write(f'''
{FILE_HEADER_COMMENT}

#include "generated.h"

namespace
{{
    struct __cmp_chr_ptr
    {{
        bool operator()(char const* a, char const* b) const
        {{
            return std::strcmp(a, b) < 0;
        }}
    }};
}}

namespace minecraft
{{

{source_content}

}}
''')